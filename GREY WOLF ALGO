import numpy as np

def gwo(obj_func, dim, search_space, n_agents=20, max_iter=100):
    lb, ub = search_space
    wolves = np.random.uniform(lb, ub, (n_agents, dim))
    alpha = np.zeros(dim)
    beta = np.zeros(dim)
    delta = np.zeros(dim)
    alpha_score, beta_score, delta_score = float("inf"), float("inf"), float("inf")

    for t in range(max_iter):
        for i in range(n_agents):
            fitness = obj_func(wolves[i])
            if fitness < alpha_score:
                delta_score, delta = beta_score, beta.copy()
                beta_score, beta = alpha_score, alpha.copy()
                alpha_score, alpha = fitness, wolves[i].copy()
            elif fitness < beta_score:
                delta_score, delta = beta_score, beta.copy()
                beta_score, beta = fitness, wolves[i].copy()
            elif fitness < delta_score:
                delta_score, delta = fitness, wolves[i].copy()

        a = 2 - 2 * (t / max_iter)  # linearly decreasing factor

        for i in range(n_agents):
            for j in range(dim):
                r1, r2 = np.random.rand(), np.random.rand()
                A1, C1 = 2 * a * r1 - a, 2 * r2
                D_alpha = abs(C1 * alpha[j] - wolves[i][j])
                X1 = alpha[j] - A1 * D_alpha

                r1, r2 = np.random.rand(), np.random.rand()
                A2, C2 = 2 * a * r1 - a, 2 * r2
                D_beta = abs(C2 * beta[j] - wolves[i][j])
                X2 = beta[j] - A2 * D_beta

                r1, r2 = np.random.rand(), np.random.rand()
                A3, C3 = 2 * a * r1 - a, 2 * r2
                D_delta = abs(C3 * delta[j] - wolves[i][j])
                X3 = delta[j] - A3 * D_delta

                wolves[i][j] = np.clip((X1 + X2 + X3) / 3.0, lb, ub)

    return alpha.copy(), alpha_score


def is_collision(point, grid_size, obstacles):
    x, y = int(point[0]), int(point[1])
    if x < 0 or y < 0 or x >= grid_size[0] or y >= grid_size[1]:
        return True
    for ox1, oy1, ox2, oy2 in obstacles:
        if ox1 <= x <= ox2 and oy1 <= y <= oy2:
            return True
    return False


def make_path_cost(start, goal, grid_size, obstacles):
    def path_cost(waypoints):
        waypoints = waypoints.reshape(-1, 2)
        path = [np.array(start)] + [w.astype(int) for w in waypoints] + [np.array(goal)]
        total_dist = 0.0
        penalty = 0.0
        energy = 0.0

        for i in range(len(path) - 1):
            dist = np.linalg.norm(path[i + 1] - path[i])
            total_dist += dist
            if is_collision(path[i + 1], grid_size, obstacles):
                penalty += 100.0

        for i in range(1, len(path) - 1):
            v1 = path[i] - path[i - 1]
            v2 = path[i + 1] - path[i]
            n1 = np.linalg.norm(v1)
            n2 = np.linalg.norm(v2)
            if n1 > 1e-9 and n2 > 1e-9:
                cos_angle = np.dot(v1, v2) / (n1 * n2)
                cos_angle = np.clip(cos_angle, -1.0, 1.0)
                angle = np.arccos(cos_angle)
                energy += angle

        return total_dist + 5.0 * energy + penalty

    return path_cost


if __name__ == "__main__":
    print("=== Grey Wolf Optimizer (Path Planning) ===")
    grid_size = tuple(map(int, input("Enter grid size (e.g., 20 20): ").split()))
    start = np.array(list(map(int, input("Enter start point (x y): ").split())))
    goal = np.array(list(map(int, input("Enter goal point (x y): ").split())))

    n_waypoints = int(input("Enter number of waypoints: "))
    n_agents = int(input("Enter number of wolves (agents): "))
    max_iter = int(input("Enter maximum iterations: "))

    obstacles = []
    n_obs = int(input("Enter number of rectangular obstacles: "))
    if n_obs > 0:
        print("Enter obstacle coordinates as: x1 y1 x2 y2")
    for i in range(n_obs):
        ox1, oy1, ox2, oy2 = map(int, input(f"Obstacle {i+1}: ").split())
        obstacles.append((ox1, oy1, ox2, oy2))

    dim = n_waypoints * 2
    path_cost = make_path_cost(start, goal, grid_size, obstacles)

    lb = 0.0
    ub = float(max(grid_size[0] - 1, grid_size[1] - 1))
    best_waypoints_flat, best_score = gwo(path_cost, dim, (lb, ub), n_agents=n_agents, max_iter=max_iter)

    best_waypoints = best_waypoints_flat.reshape(-1, 2).astype(int)
    final_path = np.vstack([start, best_waypoints, goal])

    clean_path = []
    for p in final_path:
        pt = (int(p[0]), int(p[1]))
        if len(clean_path) == 0 or pt != clean_path[-1]:
            clean_path.append(pt)

    print("\n=== Best Path Found ===")
    for p in clean_path:
        print(p)
    print("\nPath Cost:", round(best_score, 2))
